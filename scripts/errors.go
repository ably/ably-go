package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

func main() {
	flag.Parse()
	a := flag.Args()
	if len(a) > 0 {
		f, err := ioutil.ReadFile(a[0])
		if err != nil {
			log.Fatal(err)
		}
		re := regexp.MustCompile(`\/\*([\s\S]*?)\*\/`)

		// we remove the multiline comments
		f = re.ReplaceAll(f, []byte{})

		m := make(map[int]string)
		err = json.Unmarshal(f, &m)
		if err != nil {
			log.Fatal(err)
		}
		var keys []int
		for k := range m {
			keys = append(keys, k)
		}
		sort.Ints(keys)
		tpl, err := template.New("errors").Funcs(template.FuncMap{
			"toName": func(k int) string {
				return toName(m[k])
			},
		}).Parse(errTpl)
		if err != nil {
			log.Fatal(err)
		}
		var buf bytes.Buffer
		err = tpl.Execute(&buf, keys)
		if err != nil {
			log.Fatal(err)
		}
		src, err := format.Source(buf.Bytes())
		if err != nil {
			log.Fatal(err)
		}
		if len(a) > 1 {
			out := a[1]
			err = ioutil.WriteFile(out, src, 0600)
			if err != nil {
				log.Fatal(err)
			}
		} else {
			fmt.Println(string(src))
		}
	}
}

const errTpl = `// Code generated by go:generate DO NOT EDIT.

package ably

// ably error codes
const(
	{{- range .}}
	Err{{toName .}} ={{.}}
	{{- end}}
)
`

var names = map[string]string{
	"invalid use of Basic auth over non-TLS transport": "InvalidUseOfBasicAuthOverNonTLSTransport",
	"no error": "Nothing",
}

func toName(v string) string {
	if n, ok := names[v]; ok {
		return n
	}
	idx := strings.Index(v, ")")
	if idx != -1 {
		v = v[:idx]
	}
	v = strings.Replace(v, "-", " ", -1)
	parts := strings.Split(v, " ")
	for k := range parts {
		x := parts[k]
		switch x {
		case "id", "tls":
			parts[k] = strings.ToUpper(x)
		case "clientId":
			parts[k] = "ClientID"
		default:
			parts[k] = strings.Title(parts[k])
		}
	}
	v = strings.Join(parts, "")
	v = strings.Replace(v, "(", "", -1)
	v = strings.Replace(v, ")", "", -1)
	return v
}
